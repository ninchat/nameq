package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"net"
	"os"
	"os/signal"
	"strings"
	"sync"
	"syscall"

	"github.com/miekg/dns"
)

const (
	defaultResolvConf = "/run/nameq/resolv.conf"
	defaultHostsFile  = "/var/lib/nameq/hosts"
	defaultPidFile    = "/run/nameq/namep.pid"

	listenAddr = "127.0.0.1:53"
	answerTTL  = 1
)

var (
	localIP = net.IP{127, 0, 0, 1}
)

var (
	resolvConf string
	hostsFile  string
	pidFile    string
)

var (
	config *dns.ClientConfig

	hostsLock sync.RWMutex
	hosts     map[string]net.IP
)

func init() {
	log.SetFlags(0)
}

func main() {
	flag.StringVar(&resolvConf, "resolvconf", defaultResolvConf, "original DNS servers")
	flag.StringVar(&hostsFile, "hostsfile", defaultHostsFile, "generated by nameq")
	flag.StringVar(&pidFile, "pidfile", defaultPidFile, "for nameq (--dnsmasqpidfile)")
	flag.Parse()

	var err error

	config, err = dns.ClientConfigFromFile(resolvConf)
	if err != nil {
		log.Fatal(err)
	}

	for _, s := range config.Search {
		dns.HandleFunc(s, handleSearch)
	}

	dns.HandleFunc(".", handleGeneral)

	tcp, err := net.Listen("tcp", listenAddr)
	if err != nil {
		log.Fatal(err)
	}

	udp, err := net.ListenPacket("udp", listenAddr)
	if err != nil {
		log.Fatal(err)
	}

	c := make(chan os.Signal, 31)
	signal.Notify(c)
	writePid()
	readHosts()
	go handleSignals(c)

	go func() {
		log.Fatal(dns.ActivateAndServe(nil, udp, nil))
	}()

	log.Fatal(dns.ActivateAndServe(tcp, nil, nil))
}

// writePid writes our pid to a file.  It's used by nameq to SIGHUP us.
func writePid() {
	pidFileTmp := pidFile + ".tmp"

	f, err := os.Create(pidFileTmp)
	if err != nil {
		log.Fatal(err)
	}

	if _, err = fmt.Fprintln(f, os.Getpid()); err != nil {
		log.Fatal(err)
	}

	f.Close()

	os.Rename(pidFileTmp, pidFile)
}

// readHosts updates the global hosts map by reading hostsFile.  localhost is
// added automatically.
func readHosts() {
	newHosts := make(map[string]net.IP)

	f, err := os.Open(hostsFile)
	if err == nil {
		scanner := bufio.NewScanner(f)
		for scanner.Scan() {
			line := scanner.Text()

			if i := strings.Index(line, "#"); i >= 0 {
				line = line[:i]
			}

			fields := strings.Fields(line)
			if len(fields) >= 2 {
				if ip := net.ParseIP(fields[0]); ip != nil {
					if ip = ip.To4(); ip != nil {
						for _, name := range fields[1:] {
							newHosts[name+"."] = ip
						}
					}
				}
			}
		}
	} else {
		log.Print(err)
	}

	newHosts["localhost."] = localIP
	newHosts["localhost.localdomain."] = localIP

	hostsLock.Lock()
	hosts = newHosts
	hostsLock.Unlock()
}

// lookupHost finds name in the global hosts map.
func lookupHost(name string) net.IP {
	hostsLock.RLock()
	defer hostsLock.RUnlock()

	return hosts[name]
}

// handleSignals waits for signals and performs the required actions.
func handleSignals(c <-chan os.Signal) {
	for s := range c {
		switch s {
		case syscall.SIGTERM, syscall.SIGINT:
			os.Exit(0)

		case syscall.SIGHUP:
			readHosts()
		}
	}
}

// handleGeneral responds to a non-specific DNS request.
func handleGeneral(w dns.ResponseWriter, m *dns.Msg) {
	if len(m.Question) == 1 {
		lowerName := strings.ToLower(m.Question[0].Name)

		if ip := lookupHost(lowerName); ip != nil {
			handleLocal(w, m, ip)
			return
		}
	}

	handleRemote(w, m)
}

// handleSearchs responds to a specific DNS request.
func handleSearch(w dns.ResponseWriter, m *dns.Msg) {
	if len(m.Question) == 1 {
		lowerName := strings.ToLower(m.Question[0].Name)

		for _, s := range config.Search {
			s += "."

			if strings.HasSuffix(lowerName, s) {
				ip := lookupHost(lowerName[:len(lowerName)-len(s)])
				handleLocal(w, m, ip)
				return
			}
		}
	}

	handleRemote(w, m)
}

// handleLocal writes an original response.
func handleLocal(w dns.ResponseWriter, m *dns.Msg, ip net.IP) {
	defer w.Close()

	r := new(dns.Msg)

	if ip != nil {
		rr := &dns.A{
			Hdr: dns.RR_Header{
				Name:   m.Question[0].Name,
				Rrtype: dns.TypeA,
				Class:  dns.ClassINET,
				Ttl:    answerTTL,
			},
			A: ip,
		}

		r = r.SetReply(m)
		r.Answer = append(r.Answer, rr)
	} else {
		r = r.SetRcode(m, dns.RcodeNameError)
	}

	w.WriteMsg(r)
}

// handleRemote looks up and forwards a response from another DNS server.
func handleRemote(w dns.ResponseWriter, m *dns.Msg) {
	defer w.Close()

	for _, s := range config.Servers {
		var c dns.Client

		r, _, err := c.Exchange(m, s+":53")
		if err == nil {
			w.WriteMsg(r)
			return
		}

		log.Print(err)
	}

	r := new(dns.Msg)
	r.SetReply(m)
	w.WriteMsg(r)
}
